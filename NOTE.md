### 重点模块的设计和实现


#### 登陆模块
设计：使用JWT、网关、认证中心进行鉴定：
网关：配置路径访问的白名单，远程调用认证中心鉴定token
认证中心：主要实现登陆，注册，token校验的过程。注册实现密码MD5加密机制
JWT：负载设计：包含用户的id、用户名、手机、IP地址等非私密信息

问题：退出登陆问题，token丢失问题，续期问题，一定时间内无操作掉线问题
实现：
 redisTemplate.opsForValue().set("token::"+o.getId(),o.getIpAddr(),Integer.parseInt(expire),TimeUnit.SECONDS);
1、以用户id作为Key，初次登陆的IP地址为val存入redis，并且设定过期时间
2、解析token，并且以解析的信息去redis中查询对应的key-val进行检验
3、每次用户携带token访问都会刷新过期时间，长时间无操作则会redis数据过期。认证失败
4、如果访问过程IP地址发生改变则会认证失败
5、退出登陆则删除redis中的数据

#### 商品模块
简单商品增删改查
上架功能：点击上架，则修改对应商品在数据库的状态信息，并且同时将上架商品的信息存储在elasticsearch中
搜索商品：用户根据设置的不同商品的属性信息，关键字等搜索商品！主要利用elasticsearch作为搜索引擎实现（搜索条件的封装：shopmall-search中的ProSearchDTO类）

热点数据使用redis存储：设置过期时间目标是最终一致性！针对实时性要求不高的数据
数据过期时采用分布式锁、双重检查 进行加锁获取

#### 订单模块
支付功能：考虑接口幂等性 只有当订单状态为未支付时才能支付成功。使用sql语句实现
提交订单：接口幂等性 采用token机制实现。确认订单前生成token存储在redis中 token作为key。提交订单时验证是否存在这个token。存在则确认成功，生成订单并且删除token。不存在这个token则说明重复确认，不生成订单

事务回滚处理：（基于消息的最终一致性解决方案）
当订单创建失败是需要回滚锁定的商品库存
当订单超时未支付时订单取消，库存回滚
方案1：使用seata分布式事务
方案2：使用MQ构造延时队列达到事务的最终一致性（适合并发量大时）

设计：
订单创建则发送消息到延迟队列，30分钟后消费者简单订单是否支付！未支付则发送消息到仓库回滚队列，仓库消费者回滚锁定的库存
库存扣减时，发送消息到延迟队列。30分钟后消费查看订单是否为空！为空则说明创建订单失败，回滚库存

重点：MQ消息的丢失以及重复消费问题！
重复消费问题：将数据修改变成幂等操作！
消息丢失：改成手动ACK，并且实现三次回调函数记录在日志中！人工解决

#### 秒杀模块
任务扫描：每日定时任务扫描三天内的秒杀任务！将扫描到的任务信息、商品信息存储提前存储在redis中。将对应的商品设置好信号量！（redis预热）
接口防刷：上架redis时对没一件商品设置随机码。只有在秒杀开始访问才会暴露随机码，并且确认订单时需要携带随机码！
限制分钟内访问次数：将访问者的IP地址记录在reids中设置过期时间为一分钟，每访问一次则原子加一操作，超过次数则拦截（设置在网关层）
幂等：每个用户只准秒杀同样的商品一次。使用redis的setnx操作，使用用户id和商品id作为key存储

流量削峰：添加答题系统 或 验证码系统 延迟用户下单时间

整合sentinal做限流
秒杀流程：流程：下单 -》 校验时间、随机码、幂等、限购 -》 扣减信号量 -》发送消息 -》创建订单
1、服务单一部署            √
2、秒杀连接加密            √
3、库存预热                √
4、动静分离
5、恶意请求拦截             √
6、流量削峰                √
7、限流熔断降级             √
8、队列削峰                √

### 理论知识：
#### 数据一致性方面：
对于数据一致性要求不是很严格的情况下：使用spring-cache代理存储数据
对于数据一致性要求严格的情况：
方案1：延时双删策略
方案2：先删除缓存再改数据库再修改缓存（原理 写操作比读操作费时间）
方案3：使用分布式锁只允许一个线程修改缓存（并发量少的时候）
方案4：对于写频繁的数据不设置缓存

#### 分布式锁的设计
基于redis的分布式锁  考虑三个问题：独享、无死锁、活性（只要大部分Redis节点都活着，客户端就可以获取和释放锁）
上锁：
使用setnx命令：当key不存在时则set操作。随机生成UUID作为val ，在删除时匹配。避免锁的错误删除 设置过期时间以及配合try catch操作
解锁使用redis脚本进行 比较，删除的原子性操作
~~~java
if (redisTemplate.opsForValue().setIfAbsent(categeoryLockKey,token,1,TimeUnit.MINUTES)){

}finally {
    //TODO lua脚本 原子性释放锁
    String script = "if redis.call(\"get\",KEYS[1]) == ARGV[1] then return redis.call(\"del\",KEYS[1]) else return 0 end";
    redisTemplate.execute(new DefaultRedisScript<Long>(script, Long.class), Arrays.asList(categeoryLockKey), token);
    //TODO 代解决问题 redis集群中，master节点挂掉则会造成多个实例获取锁
    break;
}
~~~
问题：
1、客户端A从master获取到锁
2、在master将锁同步到slave之前，master宕掉了。
3、slave节点被晋级为master节点
4、客户端B取得了同一个资源被客户端A已经获取到的另外一个锁。安全失效！
解决：Redlock算法：客户端计算出与master获得锁操作过程中消耗的时间，当且仅当Client获得锁消耗的时间小于锁的存活时间，并且在一半以上的master节点中获得锁。才认为client成功的获得了锁。
详情看redis官网
使用基于redlock算法的 redisson框架

####缓存雪崩、缓存穿透、缓存击穿
缓存雪崩：大面积的key同时过期。解决方法：key的过期时间在原本的基础上加锁一个随机数
缓存穿透：在redis存储null值，或者使用布隆过滤器
缓存击穿：热点key用不过期 或者 当key过期时使用分布式锁让一个线程去更新缓存

### 高并发下的选择 强一致性 弱一致性 最终一致性 (柔性事务)


### CAP raft理论
CP 、AP

### 提高响应速度---异步编程
Java异步编程知识

### MQ消息 消息丢失 消息挤压 重复消费
消息丢失：消息丢失主要分布在三个阶段（对于RabbitMQ）
        生产者发送：在回调函数中做好日志
        broker发送到QUEUE：启动MQ的回调函数 做好日志
        消费者消费确认：改为手动确认接收
消息积压：增加消费者数量！编写临时消费者简单消费消息
消息重复：消费消息时做好接口幂等性


#### JWT
**JWT组成**
1、header(头部):
~~~text
{
  'typ': 'JWT', 
  'alg': 'HS256'
}
表示类型为jwt  加密算法为HS256
~~~
将头部消息进行base64编码（对称加密，可破解）得到toekn的第一段吧

2、playload（负载）:
负载分为三个部分：1、标准声明 2、公共声明 3、私有声明

标准声明：
iss: jwt签发者
sub: jwt所面向的用户
aud: 接收jwt的一方
exp: jwt的过期时间，这个过期时间必须要大于签发时间
nbf: 定义在什么时间之前，该jwt都是不可用的.
iat: jwt的签发时间
jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击

公共的声明 ：公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.
私有的声明 ： 私有声明是提供者和消费者所共同定义的声明

3、signature（签名）：
这个部分需要base64加密后的header和base64加密后的payload使用.连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分

JWT如何校验：
服务器应用对头部和载荷再次以同样方法签名之后发现，自己计算出来的签名和接受到的签名不一样，那么就说明这个Token的内容被别人动过的。

JWT的安全问题：
因为JWT的头部和负载都是使用的base64进行加密的，因此负载不应该存放私密信息！
使用HTTPS协议

###seata
三种事务模式：
AT模式
TCC模式
Saga模式
